-- Insert roles
insert into user_db.usr.role (created_at, updated_at, role_name)
VALUES (current_timestamp, current_timestamp, 'GUEST'),
       (current_timestamp, current_timestamp, 'USER'),
       (current_timestamp, current_timestamp, 'MANAGER'),
       (current_timestamp, current_timestamp, 'ADMIN'),
       (current_timestamp, current_timestamp, 'SYSTEM')
on conflict (role_name) do nothing;

-- Insert permissions
insert into user_db.usr.permission (created_at, updated_at, permission_name)
-- AUTHENTICATION
VALUES (current_timestamp, current_timestamp, 'VIEW_PUBLIC_INFO'),
       (current_timestamp, current_timestamp, 'REGISTER_ACCOUNT'),
       (current_timestamp, current_timestamp, 'LOGIN'),
       (current_timestamp, current_timestamp, 'LOGOUT'),

       -- USER PROFILE
       (current_timestamp, current_timestamp, 'VIEW_OWN_PROFILE'),
       (current_timestamp, current_timestamp, 'UPDATE_OWN_PROFILE'),
       (current_timestamp, current_timestamp, 'VIEW_ALL_USERS'),
       (current_timestamp, current_timestamp, 'UPDATE_ANY_USER'),
       (current_timestamp, current_timestamp, 'DELETE_USER'),

       -- ACCOUNTS
       (current_timestamp, current_timestamp, 'OPEN_ACCOUNT'),
       (current_timestamp, current_timestamp, 'VIEW_OWN_ACCOUNTS'),
       (current_timestamp, current_timestamp, 'VIEW_ALL_ACCOUNTS'),
       (current_timestamp, current_timestamp, 'FREEZE_ACCOUNT'),
       (current_timestamp, current_timestamp, 'UNFREEZE_ACCOUNT'),
       (current_timestamp, current_timestamp, 'CLOSE_ACCOUNT'),

       -- TRANSACTIONS
       (current_timestamp, current_timestamp, 'MAKE_TRANSACTION'),
       (current_timestamp, current_timestamp, 'VIEW_OWN_TRANSACTIONS'),
       (current_timestamp, current_timestamp, 'VIEW_ALL_TRANSACTIONS'),
       (current_timestamp, current_timestamp, 'APPROVE_LARGE_TRANSACTION'),
       (current_timestamp, current_timestamp, 'ROLLBACK_TRANSACTION'),
       -- ROLES & PERMISSIONS
       (current_timestamp, current_timestamp, 'VIEW_ROLES_AND_PERMISSIONS'),
       (current_timestamp, current_timestamp, 'ASSIGN_ROLES'),
       (current_timestamp, current_timestamp, 'MANAGE_PERMISSIONS'),

       -- NOTIFICATIONS & AUDIT
       (current_timestamp, current_timestamp, 'VIEW_OWN_NOTIFICATIONS'),
       (current_timestamp, current_timestamp, 'VIEW_AUDIT_LOGS'),

       -- SYSTEM
       (current_timestamp, current_timestamp, 'DO_INTERNAL_TASKS')
on conflict (permission_name) do nothing;

-- Associate permissions with roles
-- SYSTEM
insert into user_db.usr.role_permission (role_id, permission_id)
VALUES ((select id from user_db.usr.role where role = 'SYSTEM'),
        (select id from user_db.usr.permission where permission = 'DO_INTERNAL_TASKS'))
on conflict (role_id, permission_id) do nothing;

-- Associate permissions with roles
-- GUEST
insert into user_db.usr.role_permission (role_id, permission_id)
VALUES ((select id from user_db.usr.role where role = 'GUEST'),
        (select id from user_db.usr.permission where permission = 'VIEW_PUBLIC_INFO')),
       ((select id from user_db.usr.role where role = 'GUEST'),
        (select id from user_db.usr.permission where permission = 'REGISTER_ACCOUNT')),
       ((select id from user_db.usr.role where role = 'GUEST'),
        (select id from user_db.usr.permission where permission = 'LOGIN')),
       ((select id from user_db.usr.role where role = 'GUEST'),
        (select id from user_db.usr.permission where permission = 'LOGOUT'))
on conflict (role_id, permission_id) do nothing;

-- Associate permissions with roles
-- USER
insert into user_db.usr.role_permission (role_id, permission_id)
VALUES ((select id from user_db.usr.role where role = 'USER'),
        (select id from user_db.usr.permission where permission = 'VIEW_PUBLIC_INFO')),
       ((select id from user_db.usr.role where role = 'USER'),
        (select id from user_db.usr.permission where permission = 'LOGOUT')),
       ((select id from user_db.usr.role where role = 'USER'),
        (select id from user_db.usr.permission where permission = 'VIEW_OWN_PROFILE')),
       ((select id from user_db.usr.role where role = 'USER'),
        (select id from user_db.usr.permission where permission = 'UPDATE_OWN_PROFILE')),
       ((select id from user_db.usr.role where role = 'USER'),
        (select id from user_db.usr.permission where permission = 'OPEN_ACCOUNT')),
       ((select id from user_db.usr.role where role = 'USER'),
        (select id from user_db.usr.permission where permission = 'VIEW_OWN_ACCOUNTS')),
       ((select id from user_db.usr.role where role = 'USER'),
        (select id from user_db.usr.permission where permission = 'MAKE_TRANSACTION')),
       ((select id from user_db.usr.role where role = 'USER'),
        (select id from user_db.usr.permission where permission = 'VIEW_OWN_TRANSACTIONS')),
       ((select id from user_db.usr.role where role = 'USER'),
        (select id from user_db.usr.permission where permission = 'VIEW_OWN_NOTIFICATIONS'))
on conflict (role_id, permission_id) do nothing;

-- Associate permissions with roles
-- MANAGER
insert into user_db.usr.role_permission (role_id, permission_id)
VALUES ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'VIEW_PUBLIC_INFO')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'LOGOUT')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'VIEW_OWN_PROFILE')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'UPDATE_OWN_PROFILE')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'VIEW_ALL_USERS')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'OPEN_ACCOUNT')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'VIEW_OWN_ACCOUNTS')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'VIEW_ALL_ACCOUNTS')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'FREEZE_ACCOUNT')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'UNFREEZE_ACCOUNT')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'CLOSE_ACCOUNT')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'MAKE_TRANSACTION')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'VIEW_OWN_TRANSACTIONS')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'VIEW_ALL_TRANSACTIONS')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'APPROVE_LARGE_TRANSACTION')),
       ((select id from user_db.usr.role where role = 'MANAGER'),
        (select id from user_db.usr.permission where permission = 'VIEW_OWN_NOTIFICATIONS'))
on conflict (role_id, permission_id) do nothing;

-- Associate permissions with roles
-- ADMIN
insert into user_db.usr.role_permission (role_id, permission_id)
VALUES ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'VIEW_PUBLIC_INFO')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'LOGOUT')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'VIEW_OWN_PROFILE')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'UPDATE_OWN_PROFILE')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'VIEW_ALL_USERS')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'UPDATE_ANY_USER')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'DELETE_USER')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'OPEN_ACCOUNT')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'VIEW_OWN_ACCOUNTS')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'VIEW_ALL_ACCOUNTS')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'FREEZE_ACCOUNT')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'APPROVE_LARGE_TRANSACTION')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'ROLLBACK_TRANSACTION')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'VIEW_ROLES_AND_PERMISSIONS')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'ASSIGN_ROLES')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'MANAGE_PERMISSIONS')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'VIEW_OWN_NOTIFICATIONS')),
       ((select id from user_db.usr.role where role = 'ADMIN'),
        (select id from user_db.usr.permission where permission = 'VIEW_AUDIT_LOGS'))
on conflict (role_id, permission_id) do nothing;

------------------------------------------------------------------------------------------------------------------------


INSERT INTO user_db.usr.role_permission (role_id, permission_id)
SELECT r.id, p.id
FROM user_db.usr.role r, user_db.usr.permission p
WHERE r.role_name = 'SYSTEM'
  AND p.permission_name = 'DO_INTERNAL_TASKS'
ON CONFLICT (role_id, permission_id) DO NOTHING;

------------------------------------------------------------------------------------------------------------------------

INSERT INTO user_db.usr.role_permission (role_id, permission_id)
SELECT r.id, p.id
FROM user_db.usr.role r, user_db.usr.permission p
WHERE r.role_name = 'GUEST'
  AND p.permission_name IN (
                            'VIEW_PUBLIC_INFO',
                            'REGISTER_ACCOUNT',
                            'LOGIN',
                            'LOGOUT'
    )
ON CONFLICT (role_id, permission_id) DO NOTHING;

------------------------------------------------------------------------------------------------------------------------

-- SYSTEM
INSERT INTO user_db.usr.role_permission (role_id, permission_id)
SELECT r.id, p.id
FROM user_db.usr.role r
         JOIN user_db.usr.permission p ON TRUE
WHERE r.role_name = 'SYSTEM'
  AND p.permission_name = 'DO_INTERNAL_TASKS'
ON CONFLICT (role_id, permission_id) DO NOTHING;


-- GUEST
INSERT INTO user_db.usr.role_permission (role_id, permission_id)
SELECT r.id, p.id
FROM user_db.usr.role r
         JOIN user_db.usr.permission p
              ON p.permission_name IN (
                                       'VIEW_PUBLIC_INFO',
                                       'REGISTER_ACCOUNT',
                                       'LOGIN',
                                       'LOGOUT')
WHERE r.role_name = 'GUEST'
  AND EXISTS (SELECT 1 FROM user_db.usr.role WHERE role_name = 'GUEST')
  AND EXISTS (SELECT 1 FROM user_db.usr.permission
              WHERE permission_name IN ('VIEW_PUBLIC_INFO', 'REGISTER_ACCOUNT', 'LOGIN', 'LOGOUT'))
ON CONFLICT (role_id, permission_id) DO NOTHING;

-- USER
INSERT INTO user_db.usr.role_permission (role_id, permission_id)
SELECT r.id, p.id
FROM user_db.usr.role r,
     user_db.usr.permission p
WHERE r.role_name = 'USER'
  AND p.permission_name IN (
                            'VIEW_PUBLIC_INFO',
                            'LOGOUT',
                            'VIEW_OWN_PROFILE',
                            'UPDATE_OWN_PROFILE',
                            'OPEN_ACCOUNT',
                            'VIEW_OWN_ACCOUNTS',
                            'MAKE_TRANSACTION',
                            'VIEW_OWN_TRANSACTIONS',
                            'VIEW_OWN_NOTIFICATIONS'
    )
ON CONFLICT (role_id, permission_id) DO NOTHING;

-- MANAGER
INSERT INTO user_db.usr.role_permission (role_id, permission_id)
SELECT r.id, p.id
FROM user_db.usr.role r,
     user_db.usr.permission p
WHERE r.role_name = 'MANAGER'
  AND p.permission_name IN (
                            'VIEW_PUBLIC_INFO',
                            'LOGOUT',
                            'VIEW_OWN_PROFILE',
                            'UPDATE_OWN_PROFILE',
                            'VIEW_ALL_USERS',
                            'OPEN_ACCOUNT',
                            'VIEW_OWN_ACCOUNTS',
                            'VIEW_ALL_ACCOUNTS',
                            'FREEZE_ACCOUNT',
                            'UNFREEZE_ACCOUNT',
                            'CLOSE_ACCOUNT',
                            'MAKE_TRANSACTION',
                            'VIEW_OWN_TRANSACTIONS',
                            'VIEW_ALL_TRANSACTIONS',
                            'APPROVE_LARGE_TRANSACTION',
                            'VIEW_OWN_NOTIFICATIONS'
    )
ON CONFLICT (role_id, permission_id) DO NOTHING;

-- ADMIN
INSERT INTO user_db.usr.role_permission (role_id, permission_id)
SELECT r.id, p.id
FROM user_db.usr.role r,
     user_db.usr.permission p
WHERE r.role_name = 'ADMIN'
  AND p.permission_name IN (
                            'VIEW_PUBLIC_INFO',
                            'LOGOUT',
                            'VIEW_OWN_PROFILE',
                            'UPDATE_OWN_PROFILE',
                            'VIEW_ALL_USERS',
                            'UPDATE_ANY_USER',
                            'DELETE_USER',
                            'OPEN_ACCOUNT',
                            'VIEW_OWN_ACCOUNTS',
                            'VIEW_ALL_ACCOUNTS',
                            'FREEZE_ACCOUNT',
                            'APPROVE_LARGE_TRANSACTION',
                            'ROLLBACK_TRANSACTION',
                            'VIEW_ROLES_AND_PERMISSIONS',
                            'ASSIGN_ROLES',
                            'MANAGE_PERMISSIONS',
                            'VIEW_OWN_NOTIFICATIONS',
                            'VIEW_AUDIT_LOGS'
    )
ON CONFLICT (role_id, permission_id) DO NOTHING;

------------------------------------------------------------------------------------------------------------------------

//        return Flux.fromIterable(rolePermission.entrySet())
//                .flatMap(entry -> {
//                    RoleEnum roleName = entry.getKey();
//                    Set<PermissionEnum> permissionEnums = entry.getValue();
//
//                    // first ensure the role exists
//                    return roleRepository.findByRoleName(roleName)
//                            .switchIfEmpty(Mono.defer(() -> {
//                                log.info("Creating new role: {}", roleName);
//                                return roleRepository.save(new Role(roleName));
//                            }))
//
//                            .flatMap(role ->
//                                // then find all permissions
//                                 Flux.fromIterable(permissionEnums)
//                                        .flatMap(permissionRepository::findByPermissionEnum)
//                                        .collectList()
//                                        .flatMap(permissions -> {
//                                            if (permissions.isEmpty()) {
//                                                log.warn("No permissions found for role: {}", roleName);
//                                                return Mono.empty();
//                                            }
//                                            return rolePermissionLinkService.savePermissionsForRole(role, new HashSet<>(permissions));
//                                        });
//                            );
//                })
//                .then();
//                    return Flux.fromIterable(permissionEnums)
//                            .flatMap(permissionRepository::findByPermissionEnum)
//                            .collect(Collectors.toSet())
//
//                            .flatMap(permissions ->
//                                    roleRepository.findByRoleName(roleName)
//                                    .switchIfEmpty(roleRepository.save(new Role(roleName)))
//
//                                    .flatMap(role -> {
//                                        Mono<Role> savedRole = role.getId() == null ?
//                                                roleRepository.save(role) :
//                                                Mono.just(role);
//                                        return savedRole.flatMap(r ->
//                                                rolePermissionLinkService.savePermissionsForRole(r, permissions));
//                                            }));
//                })
//                .then();

------------------------------------------------------------------------------------------------------------------------

//    public Mono<User> createUser(UserRequest request) {
//        return Mono.zip(securityServiceClient.hashPassword(request.password())
//                        .doOnNext(pwd -> log.info("Hashed password: {}", pwd)),
//                        roleService.getDefaultRole())
//                .switchIfEmpty(Mono.error(new RuntimeException("Default role not found")))
//                .doOnNext(role -> log.info("Default role: {}", role))
//                .map(tuple -> {
//                    String password = tuple.getT1();
//                    return new User(
//                            request.username(),
//                            request.firstName(),
//                            request.lastName(),
//                            request.email(),
//                            password,
//                            request.phone(),
//                            request.age(),
//                            PENDING,
//                            roleService.getDefaultRole()
//                    );
//                });
//    }

------------------------------------------------------------------------------------------------------------------------

    public Mono<User> createUser(UserRequest request) {
        return Mono.zip(
                        securityServiceClient.hashPassword(request.password())
                                .doOnNext(pwd -> log.info("Hashed password: {}", pwd)),
                        roleService.getDefaultRole()
                                .switchIfEmpty(Mono.error(new RuntimeException("Default role not found")))
                )
                .flatMap(tuple -> {
                    String password = tuple.getT1();

                    return Mono.just(new User(
                            request.username(),
                            request.firstName(),
                            request.lastName(),
                            request.email(),
                            password,
                            request.phone(),
                            request.age(),
                            PENDING
                    ));
                });
    }

------------------------------------------------------------------------------------------------------------------------

            return requestValidation.validateRequest(request)
                    .flatMap(errors -> {
                        if (!errors.isEmpty()) {
                            String message = String.join(" ", errors);
                            log.error("Validation failed: {}", message);
                            return Mono.just(Result.error(message, BAD_REQUEST.value()));
                        }

                        return userFactory.createUser(request)
                                .doOnSubscribe(_ -> log.info("Subscribing to create user"))
                                .flatMap(userRepository::save)
                                .doOnNext(user -> log.info("Created user: {}", user))
                                .flatMap(savedUser -> {
                                    UserDto userDto = genericMapper.map(savedUser, UserDto.class);
                                    log.info("Mapped user: {}", userDto);

                                    return userTokenServiceClient.generateEmailVerificationToken(userDto)
                                            .flatMap(verificationToken -> emailSendingService.sendVerificationEmail(
                                                    userDto.email(),
                                                    userDto.username(),
                                                    verificationToken.token()
                                                    )
                                                    .then(jwtTokenServiceClient.generateJwtToken(userDto))
                                                    .doOnNext(token -> log.info("Generated token: {}", token))
                                                    .then(Mono.just(Result.<String>success("Your account has been registered. Please activate it by clicking the activation link we have sent to your email."))));
                                })
                                .doOnError(error -> log.error("Error in registration chain: ", error));
                    });

------------------------------------------------------------------------------------------------------------------------

                    //        return jwtTokenServiceClient.generateSystemToken()
                    //                .flatMap(token -> {
                    //                    log.info("Custom Log:: Generating System Token: {}", token);
                    //                    return  webClient.post()
                    //                            .uri("/api/security/web/hash-password")
                    //                            .header(AUTHORIZATION, "Bearer " + token)
                    //                            .contentType(MediaType.APPLICATION_JSON)
                    //                            .bodyValue(new PasswordHashingRequest(password))
                    //                            .retrieve()
                    //                            .onStatus(status -> status == HttpStatus.FORBIDDEN,
                    //                                    response -> response.bodyToMono(String.class)
                    //                                            .flatMap(error -> {
                    //                                                log.error("Custom Log:: Forbidden error response body: {}", error);
                    //                                                return Mono.error(new RuntimeException("Forbidden error response body: " + error));
                    //                                            }))
                    //                            .bodyToMono(String.class)
                    //                            .doOnError(error -> log.error("Custom Log:: Unable to hash password: {}", error.getMessage(), error));
                    //                });

------------------------------------------------------------------------------------------------------------------------

                    return userFactory.createUser(request)
                            .doOnSubscribe(_ -> log.info("Subscribing to create user process"))
                            .doOnNext(user -> log.info("User created: {}", user))
                            .flatMap(savedUser -> {
                                var userDto = genericMapper.map(savedUser, UserDto.class);
                                log.info("Mapped user to DTO: {}", userDto);

                                return userTokenServiceClient.generateEmailVerificationToken(userDto)
                                        .doOnNext(token -> log.info("Generated email verification token: {}", token.token()))
                                        .flatMap(token -> emailSendingService
                                                .sendVerificationEmail(
                                                        userDto.email(),
                                                        userDto.username(),
                                                        token.token()
                                                )
                                                .doOnSuccess(_ -> log.info("Verification email sent to: {}", userDto.email()))
                                                .then(jwtTokenServiceClient.generateJwtToken(userDto))
                                                .doOnNext(jwt -> log.info("Generated jwt token: {}", jwt))
                                        )
                                        .thenReturn(Result.successMessage("Your account has been registered. Please activate it by clicking the activation link we have sent to your email."));
                            })
                            .doOnError(error -> log.error("Registration failed: {}", error.getMessage(), error));
                });

------------------------------------------------------------------------------------------------------------------------

//    @Query("""
//            SELECT r.role_name AS value
//            FROM user_db.usr.user_role ur
//            JOIN user_db.usr.role r ON ur.role_id = r.id
//            WHERE ur.user_id = :userId
//            """)
//    Flux<String> findRolesByUserId(@Param("userId") Integer userId);

    @Query("""
SELECT p.permission_name AS value
FROM user_db.usr.role r
JOIN user_db.usr.role_permission rp ON r.id = rp.role_id
JOIN user_db.usr.permission p ON rp.permission_id = p.id
WHERE r.role_name = :roleName
""")
    Flux<String> findRolePermissionsByRoleName(@Param("roleName") String roleName);

------------------------------------------------------------------------------------------------------------------------

        return webClient.get()
                .uri("/api/v1/secure/local/system-token")
                .headers(header -> header.set("X-Internal-Secret", secretProperties.secret()))
                .retrieve()
                .onStatus(HttpStatusCode::isError, response -> {
                    log.error("Failed to get system token. Status: {}", response.statusCode());
                    return response.bodyToMono(String.class)
                            .defaultIfEmpty("No error body")
                            .flatMap(body -> Mono.error(new TokenGenerationException("System token request failed" + body)));
                })
                .bodyToMono(String.class)
                .doOnNext(token -> log.info("System token received: {}", token))
                .switchIfEmpty(Mono.error(new EmptyTokenException("System token generation returned empty")));

------------------------------------------------------------------------------------------------------------------------

    @Override
    public Mono<Result<String>> register(UserRequest request) {
        log.info("Initiating user registration for email: {}", request.email());

        return requestValidation.validateRequest(request)
                .doOnNext(errors -> {
                    if (!errors.isEmpty()) {
                        log.warn("Validation errors occurred during registration: {}", errors);
                    } else {
                        log.info("Validation passed for: {}", request.email());
                    }
                })
                .flatMap(errors -> {
                    if (!errors.isEmpty()) {
                        String message = String.join(" ", errors);
                        return Mono.just(Result.error(message, BAD_REQUEST.value()));
                    }

                    return userFactory.createUser(request)
                            .doOnSubscribe(_ -> log.info("Subscribing to create user process"))
                            .doOnNext(user ->  log.info("Created user: {}", user))
                            .flatMap(user -> userReactiveMapper.map(user)
                                    .doOnNext(dto -> log.info("Mapped User to DTO: {}", dto))
                                    .doOnNext(dto -> log.info("About to generate verification token for: {}", dto.email()))
                                    .zipWhen(this::generateVerificationToken)
                                    .doOnNext(tuple -> log.info("Zipped DTO and Token: {}",  tuple.getT2().token()))
                                    .flatMap(this::sendVerificationEmailAndGenerateJwt)
                            )
                            .doOnError(error -> log.error("Error while creating user: {}", error.getMessage(), error));
                });
    }

------------------------------------------------------------------------------------------------------------------------

    @GetMapping("/system-token")
    public Mono<ResponseEntity<String>> generateSystemToken(ServerHttpRequest request) {
        String secret = request.getHeaders().getFirst("X-Internal-Secret");
        if (!internalSecretProperties.secret().equals(secret)) {
            log.warn("Custom Log:: Invalid internal secret from {}", request.getRemoteAddress());
            return Mono.just(ResponseEntity.status(FORBIDDEN).body("Invalid internal secret"));
        }
        return Mono.fromSupplier(jwtTokenService::generateSystemToken)
                .doOnNext(token -> log.info("Internal token generated: {}", token))
                .map(ResponseEntity::ok);
    }

------------------------------------------------------------------------------------------------------------------------

    @Retry(name = "securityService")
    @CircuitBreaker(name = "securityService")
    @Override
    public Mono<TokenResponse> generateEmailVerificationToken(UserDto user) {
        return jwtTokenServiceClient.generateSystemToken()
                .switchIfEmpty(Mono.error(new EmptyTokenException("System token generation returned empty")))
                .flatMap(token ->
                        webClient.post()
                                .uri("/api/internal/security/generate-email-verification-token")
                                .header(AUTHORIZATION, "Bearer " + token)
                                .contentType(APPLICATION_JSON)
                                .bodyValue(user)
                                .exchangeToMono(response -> {
                                    HttpStatusCode statusCode = response.statusCode();

                                    if (statusCode.is2xxSuccessful()) {
                                        return response.bodyToMono(TokenResponse.class)
                                                .doOnNext(body ->
                                                        log.info("Email verification response: {}", body.token()))
                                                .switchIfEmpty(Mono.error(
                                                        new EmptyTokenException("Email verification returned empty body")));
                                    } else {
                                        return response.bodyToMono(TokenResponse.class)
                                                .switchIfEmpty(Mono.error(
                                                        new EmptyTokenException("Email verification returned empty body")))
                                                .flatMap(error -> {
                                                    log.error("Email verification token generation failed - status: {}, body: {}", statusCode.value(), error);
                                                    return Mono.error
                                                            (new EmptyTokenException("Email verification token generation failed - " + error));
                                                });
                                    }
                                })
                                .timeout(Duration.ofSeconds(10))
                                .doOnError(error ->
                                        log.error("Email verification token generation failed: {}", error.getMessage(), error)));
    }

------------------------------------------------------------------------------------------------------------------------

//    @Override
//    public Mono<User> createUser(UserRequest request) {
//        log.info("Creating user with username: {}", request.username());
//
//        return roleService.getDefaultRole()
//                .map(set -> set.iterator().next())
//                .doOnNext(role -> log.info("Retrieved default role: {}", role))
//                .doOnError(err -> log.error("Error fetching default role: {}", err.getMessage(), err))
//                .log("GET_ROLE")
//                .flatMap(defaultRole -> {
//
//                    User user = new User(
//                            request.username(),
//                            request.firstName(),
//                            request.lastName(),
//                            request.email(),
//                            request.password(),
//                            request.phone(),
//                            request.age(),
//                            PENDING
//                    );
//
//                    log.info("Saving user: {}", user.getUsername());
//                    return userRepository.save(user)
//                            .doOnNext(saved -> log.info("User saved with ID: {}", saved.getId()))
//                            .flatMap(savedUser -> {
//                                UserRole userRole = new UserRole(savedUser.getId(), defaultRole.getId());
//                                return userRoleRepository.save(userRole)
//                                        .doOnNext(_ -> log.info("Linked user '{}' to role '{}'",
//                                                savedUser.getUsername(), defaultRole.getRoleName()))
//                                        .thenReturn(savedUser);
//                            });
//                })
//                .doOnError(error -> log.error("Error during user creation: {}", error.getMessage(), error));
//    }

------------------------------------------------------------------------------------------------------------------------

return generateSystemToken()
                .flatMap(token -> {
                    log.info("Generated system token for jwt generation api call: {}", token);

                    return webClient.post()
                            .uri("api/internal/security/jwt/generate")
                            .header(AUTHORIZATION, "Bearer " + token)
                            .contentType(APPLICATION_JSON)
                            .bodyValue(new TokenRequest(user))
                            .exchangeToMono(response -> {
                                HttpStatusCode statusCode = response.statusCode();

                                if (statusCode.is2xxSuccessful()) {
                                    return response.bodyToMono(TokenResponse.class)
                                            .doOnNext(body ->
                                                    log.info("Auth JWT token response: {}", body.token()))
                                            .switchIfEmpty(Mono.error(new TokenGenerationException(
                                                    "Auth JWT token returned empty body"
                                            )));
                                } else {
                                    return response.bodyToMono(TokenResponse.class)
                                            .switchIfEmpty(Mono.error(new TokenGenerationException(
                                                    "Auth JWT token returned empty body"
                                            )))
                                            .flatMap(error -> {
                                                log.error("Auth JWT generation failed- status: {}, body: {}", statusCode.value(), error);
                                                return Mono.error(new TokenGenerationException(
                                                        "Auth JWT generation failed- status: " + statusCode.value() + "-" + error
                                                ));
                                            });
                                }
                            })
                            .timeout(Duration.ofSeconds(5))
                            .doOnError(error -> log.error("Auth JWT generation failed: {}", error.getMessage(), error));
                });

------------------------------------------------------------------------------------------------------------------------

        return webClient.get()
                .uri("/api/v1/secure/local/system-token")
                .headers(header -> header.set("X-Internal-Secret", secretProperties.secret()))
                .retrieve()
                .onStatus(HttpStatusCode::isError, response -> {
                    log.error("Failed to get system token. Status: {}", response.statusCode());

                    return response.bodyToMono(String.class)
                            .defaultIfEmpty("No error body")
                            .flatMap(body -> Mono.error(new TokenGenerationException(
                                    "System token request failed: " + response.statusCode() + " - " +  body)));
                })
                .bodyToMono(String.class)
                .doOnNext(token -> {
                    if (token == null || token.isEmpty() || token.trim().isBlank()) {
                        log.error("Received empty system token");
                        throw new EmptyTokenException("Received empty system token");
                    }
                    log.info("Received System token: {}", token);
                })
                .timeout(Duration.ofSeconds(10),
                        Mono.error(new TimeoutException("System token generation timed out")));

------------------------------------------------------------------------------------------------------------------------

        return generateSystemToken()
                .flatMap(systemToken -> {
                    log.info("validating auth jwt token: {}", systemToken);

                    return webClient.post()
                            .uri("api/internal/security/jwt/validate")
                            .header(AUTHORIZATION, "Bearer " + systemToken)
                            .contentType(APPLICATION_JSON)
                            .bodyValue(new TokenValidatorRequest(systemToken, username))
                            .exchangeToMono(response -> {
                                HttpStatusCode statusCode = response.statusCode();

                                if (statusCode.is2xxSuccessful()) {
                                    return response.bodyToMono(TokenValidatorResponse.class)
                                            .doOnNext(body ->
                                                    log.info("Auth jwt token validation response: {}", body.valid()))
                                            .switchIfEmpty(Mono.error(new TokenValidationException(
                                                    "Auth jwt token validation returned empty body"
                                            )));
                                } else {
                                    return response.bodyToMono(TokenValidatorResponse.class)
                                            .switchIfEmpty(Mono.error(new TokenValidationException(
                                                    "Auth jwt token validation returned empty body"
                                            )))
                                            .flatMap(error -> {
                                                log.error("Auth jwt token validation failed - status : {}, body: {}", statusCode.value(), error);
                                                return Mono.error(new TokenValidationException(
                                                        "Auth jwt token validation failed - status: " + statusCode.value() + "-" + error
                                                ));
                                            });
                                }
                            })
                            .timeout(Duration.ofSeconds(5))
                            .doOnError(error -> log.error("Auth jwt token validation failed: {}", error.getMessage(), error));
                });

------------------------------------------------------------------------------------------------------------------------

//        return webClient.post()
//                .uri("/api/internal/security/authorize")
//                .bodyValue(new AuthorizationRequest(token, permission))
//                .retrieve()
//                .bodyToMono(Boolean.class)
//                .doOnError(error -> log.error("Custom Log:: unable to generate token: {}", error.getMessage(), error));

------------------------------------------------------------------------------------------------------------------------

 return jwtTokenServiceClient.generateSystemToken()
                .flatMap(token -> {
                    log.info("Generating system token for password hashing call: {}", token);
                    return webClient.post()
                            .uri("/api/internal/security/password/hash")
                            .header(AUTHORIZATION, "Bearer " + token)
                            .contentType(APPLICATION_JSON)
                            .bodyValue(new PasswordHashingRequest(password))
                            .exchangeToMono(response -> {
                                HttpStatusCode status = response.statusCode();

                                if (status.is2xxSuccessful()) {
                                    return response.bodyToMono(PasswordHashingResponse.class)
                                            .doOnNext(body -> log.info(
                                                    "Password hashing response: {}", body.hashedPassword()))
                                            .switchIfEmpty(Mono.error(new RuntimeException("Password hash returned empty body")));
                                } else {
                                    return response.bodyToMono(PasswordHashingResponse.class)
                                            .switchIfEmpty(Mono.error(new RuntimeException("Password hash returned empty body")))
                                            .flatMap(error -> {
                                                log.error("Password hashing failed - status: {}, body: {}", status.value(), error);
                                                return  Mono.error(new RuntimeException(
                                                        "Password hashing failed with status: " + status.value() + " - " + error));
                                            });
                                }
                            })
                            .timeout(Duration.ofSeconds(5))
                            .doOnError(error -> log.error("Password hashing failed: {}", error.getMessage(), error));
                });

------------------------------------------------------------------------------------------------------------------------

 return jwtTokenServiceClient.generateSystemToken()
                .flatMap(token -> {
                    log.info("generate system token for jwt token validation call: {}", token);

                    return  webClient.post()
                            .uri("api/internal/security/password/validate")
                            .header(AUTHORIZATION, "Bearer " + token)
                            .contentType(APPLICATION_JSON)
                            .bodyValue(new PasswordValidatorRequest(rawPassword, hashedPassword))
                            .exchangeToMono(response -> {
                                HttpStatusCode status = response.statusCode();

                                if(status.is2xxSuccessful()) {
                                    return response.bodyToMono(Boolean.class)
                                            .doOnNext(body ->
                                                    log.info("Password validation body: {}", body))
                                            .switchIfEmpty(Mono.error(new PasswordValidationException(
                                                    "Password validation returned empty body"
                                            )));
                                } else {
                                    return response.bodyToMono(Boolean.class)
                                            .switchIfEmpty(Mono.error(new PasswordValidationException(
                                                    "Password validation returned empty body"
                                            )))
                                            .flatMap(error -> {
                                                log.error("Password validation filed - status: {}, body: {}", status.value(), error);
                                                return  Mono.error(new PasswordValidationException(
                                                        "Password validation failed with status: " + status.value() + " - " + error
                                                ));
                                            });
                                }
                            })
                            .timeout(Duration.ofSeconds(5))
                            .doOnError(error -> log.error("Password validation failed: {}", error.getMessage(), error));
                });

------------------------------------------------------------------------------------------------------------------------

return jwtTokenServiceClient.generateSystemToken()
                .switchIfEmpty(Mono.error(new EmptyTokenException("System token generation returned empty")))
                .flatMap(token ->
                        webClient.post()
                                .uri("/api/internal/security/user-token/email/issue")
                                .header(AUTHORIZATION, "Bearer " + token)
                                .contentType(APPLICATION_JSON)
                                .bodyValue(user)
                                .exchangeToMono(response -> {
                                    HttpStatusCode statusCode = response.statusCode();

                                    if (statusCode.is2xxSuccessful()) {
                                        return response.bodyToMono(TokenResponse.class)
                                                .switchIfEmpty(Mono.error(new EmptyTokenException("Email verification returned empty body")));
                                    } else {
                                        return response.createException()
                                                .flatMap(error -> {log.error(
                                                        "Email verification token generation failed - status: {}, body: {}",
                                                            statusCode.value(), error.getResponseBodyAsString());
                                                    return Mono.error(new EmptyTokenException(
                                                            "Email verification token generation failed - " + error.getMessage()));
                                                });
                                    }
                                })
                                .timeout(Duration.ofSeconds(10))
                                .doOnError(error -> log.error(
                                        "Email verification token generation failed: {}", error.getMessage(), error)));

------------------------------------------------------------------------------------------------------------------------

 return webClient.post()
                .uri("/api/internal/security/user-token/email/validate")
                .bodyValue(new TokenValidatorRequest(token, username))
                .retrieve()
                .bodyToMono(Boolean.class)
                .doOnError(error -> log.error("Custom Log:: unable to generate token: {}", error.getMessage(), error));

------------------------------------------------------------------------------------------------------------------------

return webClient.post()
                .uri("/api/internal/security/user-token/password-reset/issue")
                .bodyValue(user)
                .retrieve()
                .bodyToMono(TokenResponse.class)
                .doOnError(error -> log.error("Custom Log:: unable to generate token: {}", error.getMessage(), error));

------------------------------------------------------------------------------------------------------------------------

return webClient.post()
                .uri("/api/internal/security/user-token/password-reset/validate")
                .bodyValue(new TokenValidatorRequest(token, username))
                .retrieve()
                .bodyToMono(Boolean.class)
                .doOnError(error -> log.error("Custom Log:: unable to generate token: {}", error.getMessage(), error));

------------------------------------------------------------------------------------------------------------------------

return webClient.post()
                .uri("/api/internal/security/token/invalidate")
                .bodyValue(new TokenResponse(token))
                .retrieve()
                .bodyToMono(Void.class)
                .doOnError(error -> log.error("Custom Log:: unable to generate token: {}", error.getMessage(), error));

------------------------------------------------------------------------------------------------------------------------

    @Override
    public Mono<Result<String>> register(UserRequest request) {
        log.info("Initiating user registration for email: {}", request.email());

        return requestValidation.validateRequest(request)
                .doOnNext(errors -> {
                    if (!errors.isEmpty()) {
                        log.warn("Validation errors occurred during registration: {}", errors);
                    } else {
                        log.info("Validation passed for: {}", request.email());
                    }
                })
                .flatMap(errors -> {
                    if (!errors.isEmpty()) {
                        String message = String.join(" ", errors);
                        return Mono.just(Result.error(message, BAD_REQUEST.value()));
                    }

                    return userFactory.createUser(request)
                            .doOnSubscribe(_ -> log.info("Subscribing to create user process"))
                            .doOnNext(user -> log.info("Created user: {}", user))
                            .flatMap(user -> userReactiveMapper.map(user)
                                    .doOnNext(dto -> log.info("Mapped User to DTO: {}", dto))
                                    .doOnNext(dto -> log.info("About to generate verification token for: {}", dto.email()))
                                    .zipWhen(this::generateVerificationToken)
                                    .flatMap(this::sendVerificationEmailAndGenerateJwt)
                                    .onErrorResume(error -> {
                                        log.error("Error during token generation or email sending: {}", error.getMessage(), error);
                                        return Mono.just(Result.error(
                                                "Registration process failed. Please try again later.", INTERNAL_SERVER_ERROR.value()));
                                    })
                            )
                            .doOnError(error -> log.error("Error while creating user: {}", error.getMessage(), error));
                });
    }

    private Mono<AccountResponse> createDefaultAccount(AccountRequest request) {
        return currentAccountCreationClient.createDefaultAccount(request)
                .doOnNext(acc -> log.info("Created default account: {}", acc));
    }

    private Mono<TokenResponse> generateVerificationToken(UserDto userDto) {
        return userTokenServiceClient.generateEmailVerificationToken(userDto)
                .doOnNext(token -> log.info("Generated email verification token: {}", token.token()));
    }

    private Mono<Result<String>> sendVerificationEmailAndGenerateJwt(Tuple2<UserDto, TokenResponse> tuple) {
        UserDto userDto = tuple.getT1();
        TokenResponse token = tuple.getT2();

        return notificationClient.sendVerificationEmail(userDto.email(), userDto.username(), token.token())
                .doOnSuccess(_ -> log.info("Verification email sent to: {}", userDto.email()))
                .then(userTokenClient.generateJwtAccessToken(userDto))
                .thenReturn(Result.successMessage(
                        "Your account has been registered. Please activate it by clicking the activation link we have sent to your email."));
    }

------------------------------------------------------------------------------------------------------------------------
