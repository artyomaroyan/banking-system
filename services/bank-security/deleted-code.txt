//    @Bean
//    protected ReactiveJwtAuthenticationConverter jwtAuthenticationConverter() {
//        ReactiveJwtAuthenticationConverter converter = new ReactiveJwtAuthenticationConverter();
//        converter.setJwtGrantedAuthoritiesConverter(jwt -> {
//            List<String> authorities = jwt.getClaimAsStringList("authorities");
//            if (authorities == null || authorities.isEmpty()) {
//                return Flux.empty();
//            }
//            return Flux.fromIterable(authorities.stream()
//                    .map(role -> role.startsWith("ROLE_") ? role : "ROLE_" + role)
//                    .map(SimpleGrantedAuthority::new)
//                    .toList());
//        });
//        return converter;
//    }

------------------------------------------------------------------------------------------------------------------------

                            .permitAll()
                        .pathMatchers("/api/security/web/hash-password")
                                .authenticated()
//                            .access((mono, _) -> mono
//                                    .map(auth -> auth
//                                            .getAuthorities().stream()
//                                            .anyMatch(grantedAuthority ->
//                                                    grantedAuthority.getAuthority().equals("ROLE_SYSTEM") ||
//                                                    grantedAuthority.getAuthority().equals("DO_INTERNAL_TASKS")))
//                                    .map(AuthorizationDecision::new))

------------------------------------------------------------------------------------------------------------------------

//        String authHeader = exchange.getRequest().getHeaders().getFirst(AUTHORIZATION);
//        if (authHeader ==  null || !authHeader.startsWith("Bearer ")) {
//            return chain.filter(exchange);
//        }
//
//            String token = authHeader.substring(7);
//            return jwtTokenValidator.validateInternalToken(token)
//                    .flatMap(jwt -> {
//                        log.info("Authenticating service: {}",  jwt.getSubject());
//                        log.info("Authorities: {}", (Object) jwt.getClaim("authorities"));
//                        return chain.filter(exchange);
//                    })
//                    .onErrorResume(error -> {
//                        log.error("Authentication failed: {}", error.getMessage());
//                        exchange.getResponse().setStatusCode(UNAUTHORIZED);
//                        return exchange.getResponse().setComplete();
//                    });

------------------------------------------------------------------------------------------------------------------------

return Mono.just(token)
                .flatMap(t -> jwtDecoder.decode(t)
                        .doOnNext(jwt -> {
                            log.info("Internal token successfully decoded: {}", jwt);
                            log.info("Token claims: {}", jwt.getClaims());
                            log.info("Token headers: {}", jwt.getHeaders());
                        }))
                .doOnSuccess(jwt -> log.debug("Valid JWT for subject {}", jwt.getSubject()))
                .doOnError(error -> log.error("JWT validation failed",  error))
                .onErrorMap(error -> new OAuth2AuthenticationException(
                        new OAuth2Error("invalid_token", error.getMessage(), null),
                        "JWT validation failed"));

------------------------------------------------------------------------------------------------------------------------

return exchange ->
                Mono.just(exchange.getRequest().getPath().value())
                        .flatMap(path -> {
                            for (String ignore : CSRF_IGNORE) {
                                if (path.matches(ignore.replace("**", ""))) {
                                    return ServerWebExchangeMatcher.MatchResult.notMatch();
                                }
                            }
                            return ServerWebExchangeMatcher.MatchResult.match();
                        });

------------------------------------------------------------------------------------------------------------------------

//    @GetMapping(value = "/jwks.json", produces = MediaType.APPLICATION_JSON_VALUE)
//    public Mono<ResponseEntity<Map<String, Object>>> getJwkSet() {
//        ECPublicKey ecPublicKey = (ECPublicKey) keyProviderStrategy.getPublicKey();
//
//        ECKey ecKey = new ECKey.Builder(Curve.P_256, ecPublicKey)
//                .keyUse(KeyUse.SIGNATURE)
//                .algorithm(JWSAlgorithm.ES256)
//                .keyID(keyProviderStrategy.getKeyId())
//                .build();
//
//        JWKSet jwkSet = new JWKSet(ecKey);
//        Map<String, Object> jwkJson = jwkSet.toJSONObject();
//        log.info("JWK JSON: {}", jwkJson);
//
//        return Mono.just(ResponseEntity.ok(jwkJson));
//    }

------------------------------------------------------------------------------------------------------------------------

        var type = TokenType.INTERNAL_JWT_TOKEN;
        var credentials = tokenSigningKeyManager.getSigningCredentials(type);
        var issuedAt = new Date();
        var expiration = new Date(issuedAt.getTime() + tokenSigningKeyManager.getTokenExpiration(type));

        var builder = Jwts.builder()
                .subject(JwtTokenFactory.class.getSimpleName())
                .issuer("bank-security service")
                .issuedAt(issuedAt)
                .expiration(expiration)
                .audience().add("Internal communication Token")
                .and()
                .claim("authorities", List.of("ROLE_SYSTEM", "DO_INTERNAL_TASKS"))
                .id(UUID.randomUUID().toString())
                .header().keyId(keyProviderStrategy.getKeyId());
        return credentials.sign((JwtBuilder) builder).compact();

------------------------------------------------------------------------------------------------------------------------

        ECPrivateKey privateKey = (ECPrivateKey) keyProviderStrategy.getPrivateKey();
        String keyId = keyProviderStrategy.getKeyId();

        Instant now = Instant.now();
        Instant expiry = now.plusSeconds(600);

        JWTClaimsSet claims = new JWTClaimsSet.Builder()
                .subject(JwtTokenFactory.class.getSimpleName())
                .issuer("bank-security service")
                .issueTime(Date.from(now))
                .expirationTime(Date.from(expiry))
                .audience("Internal communication Token")
                .claim("authorities", List.of("ROLE_SYSTEM", "DO_INTERNAL_TASKS"))
                .jwtID(UUID.randomUUID().toString())
                .build();

        SignedJWT signedJWT = new SignedJWT(
                new JWSHeader.Builder(JWSAlgorithm.ES256)
                        .keyID(keyId)
                        .type(JOSEObjectType.JWT)
                        .build(),
                claims
        );

        try {
            signedJWT.sign(new ECDSASigner(privateKey));
        } catch (JOSEException ex) {
            throw new IllegalStateException("Failed to sign JWT", ex);
        }
        return signedJWT.serialize();

------------------------------------------------------------------------------------------------------------------------

#spring:
#  r2dbc:
#    url: r2dbc:postgresql://localhost:5432/security_db
#    username: security_owner
#    password: security_owner
#
#  flyway:
#    enabled: true
#    url: jdbc:postgresql://localhost:5432/security_db
#    user: security_owner
#    password: security_owner
#    locations: classpath:db/migration
#    driver-class-name: org.postgresql.Driver
#    schemas: security
#    default-schema: security
#
#security:
#  service:
#    url: http://localhost:8989
#
#  argon2:
#    memory: 65536 # Use 64 MB of memory
#    iterations: 3 # Run 3 iterations
#    parallelism: 2 # Use 2 threads
#    hashLength: 64 # Generate a 64 byte (512 bit) hash
#    salt: ${ARGON2_SALT_FOR_BANK}
#    secretKey: ${ARGON2_SECRET_KEY_FOR_BANK}
#  token:
#    jwt:
#      keystore:
#        path: /Users/artyom_aroyan/.keys/.bankapp/JWT/keystore.p12
#        alias: ${BANK_KEYSTORE_ALIAS}
#        password: ${BANK_KEYSTORE_PASSWORD}
#        expiration: 720 # expiration in minutes
#    access:
#      password-recovery:
#        secret: ${PASSWORD_RESET_TOKEN_SECRET_FOR_BANK}
#        expiration: 3 # expiration in minutes
#      email-verification:
#        secret: ${EMAIL_VERIFICATION_TOKEN_SECRET_FOR_BANK}
#        expiration: 15 # expiration in minutes

------------------------------------------------------------------------------------------------------------------------